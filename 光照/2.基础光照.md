# 2.基础光照

上一节中，我们介绍了光源颜色对物体表面颜色的影响，这一节我们就来详细的模拟一个光源。

显示世界中，光照环境往往是相对复杂的。因为假设太阳作为世界的唯一光源，那么太阳光照在物体A上A将阳光进行反射后，A又做为一个新的光源共同作用于另一个物体B。所以于B来讲光源是复杂的。然而这只是其中一个因素，受制于天气、温度等其他情况我们需要考虑的因素更多。在OpenGL中我们仅考虑一些简单的模型，对现实情况进行一个近似的模拟。这一节中我们主要介绍一下`冯氏光照模型`。冯氏光照模型中主要有3个分量构成：

![冯氏光照模型](https://learnopengl-cn.github.io/img/02/02/basic_lighting_phong.png)

- 环境光照(Ambient Lighting)：即使在黑暗的情况下，世界上通常也仍然有一些光亮（月亮、远处的光），所以物体几乎永远不会是完全黑暗的。为了模拟这个，我们会使用一个环境光照常量，它永远会给物体一些颜色。
- 漫反射光照(Diffuse Lighting)：模拟光源对物体的方向性影响(Directional Impact)。它是冯氏光照模型中视觉上最显著的分量。物体的某一部分越是正对着光源，它就会越亮。
- 镜面光照(Specular Lighting)：模拟有光泽物体上面出现的亮点。镜面光照的颜色相比于物体的颜色会更倾向于光的颜色。

接下来我们将逐一讲解这三个分量。

### 环境光照

上文中提到了，真实世界中的光源情况是复杂的。如果对系统中的每一个光源都进行考虑，这种算法叫做`全局照明算法`。**但是这种算法既开销高昂又极其复杂**。我们使用`环境光照`来简化这个概念，即使用一个很小的常量光照颜色，叠加到实际光照颜色中。

```
void main()
{
    float ambientStrength = 0.1;
    vec3 ambient = ambientStrength * lightColor;

    vec3 result = ambient * objectColor;
    FragColor = vec4(result, 1.0);
}
```

我们看到此处直接用环境颜色与物体颜色相乘。这是因为当前阶段我们还没有添加光源。

这部分代码可以看下[Demos/2.基础光照/2-1.环境光照](https://github.com/CodeWicky/Learning-OpenGL/tree/master/%E5%85%89%E7%85%A7/Demos/2.%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7/2-1.%E7%8E%AF%E5%A2%83%E5%85%89%E7%85%A7)中的相关代码。

### 漫反射光照

当光线照射在平面上时会发生镜面反射，这是一个光学常识。但事实上真实世界中的物体表面一般都不是完全的平面而是凹凸不平的（微观上的凹凸不平），此时将发生漫反射。漫反射的结果就是，你不仅可以从光源的镜像角度可以观察到物体，从各个角度你都可以观察得到。不过漫反射的强度区域光源射入平面的夹角有关。通过实验，我们观察到**当射入角度与平面法线夹角越小时，漫反射强度越强**。

我们要在GL中模拟漫反射效果。从上述的叙述中我们知道，漫反射的关键因素在于法线夹角。那么也就是说，我们在GL中需要两点，第一个是`法向量`，第二个是`光线射入的角度`。

法向量是相对于平面而言的，于点是没有意义的。而同一点在不同平面中对应的法向量也是不同的。这就决定了我们需要改造我们的顶点数据，传一组法向量给顶点着色器，此外绘制VAO时也不能以EBO绘制，而应该以VBO绘制。

> 虽然对灯的着色器使用不能完全利用的顶点数据看起来不是那么高效，但这些顶点数据已经从箱子对象载入后开始就储存在GPU的内存里了，所以我们并不需要储存新数据到GPU内存中。这实际上比给灯专门分配一个新的VBO更高效了。

### 计算漫反射光照

顶点数据中我们传入了法向量，我们还需要一个角度。顶点着色器中我们是可以拿到顶点数据的，这时只要我们拿到光源的位置即可以计算出光的方向了，标准化以后就是方向向量了。光源的位置一般是相对固定的，我们可以用uniform变量在外界对着色器进行赋值。记得将光源坐标和顶点坐标都转化为世界坐标哦，或者，因为，或者`保证光源坐标、顶点坐标和法向量在同一坐标系统内`也可。**法向量和方向向量都记得要标准化，这样他们点乘的结果才是两个向量的夹角余弦值**。

![漫反射](https://learnopengl-cn.github.io/img/02/02/diffuse_light.png)

最后，如果夹角余弦值小于零，我们认为这时无意义的，他将造成我们的漫反射分量为负值，而真实世界中，仅可能是无影响，而不会是负影响。**所以我们小于0时我们取0**。

片段着色器中的代码大概是这个样子的：

```
#version 330 core
out vec4 FragColor;
in vec3 ourColor;
in vec3 normal;
in vec3 fragPosition;
uniform vec3 ambientColor;
uniform vec3 lightColor;
uniform vec3 lightPosition;
void main()
{
    vec3 norm = normalize(normal);
    vec3 lightDir = normalize(lightPosition - fragPosition);
    float factor = max(dot(norm,lightDir),0.0);
    FragColor = vec4(ourColor * (ambientColor + lightColor * factor) , 1.0);
}
```

![法线矩阵](https://learnopengl-cn.github.io/img/02/02/basic_lighting_normal_transformation.png)

还有一件事，之前说过，要`保证光源坐标、顶点坐标和法向量在同一坐标系统内`。一般情况下我们会将他们转化为世界坐标，因为这更符合我们的直觉。我们要把法向量也转换到世界空间内。顶点数据中，你所写的法向量直觉上应该是局部坐标，所以要经过模型矩阵转换。此外，模型矩阵中我们也可能对物体进行非比例变化，这将导致我们的法向量发现也发生改变。所以在把法向量从局部坐标转化至世界坐标时，我们要经过`法线矩阵`的转换。我们可以通过逆矩阵和转置矩阵来变化模型矩阵。所以顶点着色器中我们的代码大概是这个样子的：

```
#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aColor;
layout (location = 2) in vec3 aNormal;
uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;
out vec3 ourColor;
out vec3 normal;
out vec3 fragPosition;
void main()
{
    gl_Position = projection * view * model * vec4(aPos, 1.0);
    ourColor = aColor;
    fragPosition = vec3(model * vec4(aPos,1.0));
    normal = mat3(transpose(inverse(model))) * aNormal;
}
```

其中inverse()是求逆矩阵函数，transpose是求转置矩阵函数。

这部分代码可以看下[Demos/2.基础光照/2-2.漫反射光照](https://github.com/CodeWicky/Learning-OpenGL/tree/master/%E5%85%89%E7%85%A7/Demos/2.%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7/2-2.%E6%BC%AB%E5%8F%8D%E5%B0%84%E5%85%89%E7%85%A7)中的相关代码。

### 镜面光照










