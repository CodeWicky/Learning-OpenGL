# 7.变换

在GL中同样存在仿射变换。这涉及到矩阵运算，这里我们只做一个简单的介绍。

### 向量

> 一个具有方向和大小的表示方向的量。

#### 向量与标量运算

> 标量(Scalar)只是一个数字（或者说是仅有一个分量的向量）。当把一个向量加/减/乘/除一个标量，我们可以简单的把向量的每个分量分别进行该运算。

![向量与标量运算](https://github.com/CodeWicky/Learning-OpenGL/raw/master/%E5%85%A5%E9%97%A8/Pics/%E5%90%91%E9%87%8F%E4%B8%8E%E6%A0%87%E9%87%8F%E8%BF%90%E7%AE%97.png)

#### 向量加减

> 向量的加法可以被定义为是分量的(Component-wise)相加，即将一个向量中的每一个分量加上另一个向量的对应分量。

![向量加减](https://github.com/CodeWicky/Learning-OpenGL/raw/master/%E5%85%A5%E9%97%A8/Pics/%E5%90%91%E9%87%8F%E5%8A%A0%E5%87%8F.png)

#### 长度

> 我们使用勾股定理(Pythagoras Theorem)来获取向量的长度(Length)/大小(Magnitude)。


因为两条边（x和y）是已知的，如果希望知道斜边v¯的长度，我们可以直接通过勾股定理来计算：

![向量的长度](https://github.com/CodeWicky/Learning-OpenGL/raw/master/%E5%85%A5%E9%97%A8/Pics/%E5%90%91%E9%87%8F%E7%9A%84%E9%95%BF%E5%BA%A6.png)

有一个特殊类型的向量叫做单位向量(Unit Vector)。单位向量有一个特别的性质——它的长度是1。我们可以用任意向量的每个分量除以向量的长度得到它的单位向量n̂ ：

![单位向量](https://github.com/CodeWicky/Learning-OpenGL/raw/master/%E5%85%A5%E9%97%A8/Pics/%E5%8D%95%E4%BD%8D%E5%90%91%E9%87%8F.png)

我们把这种方法叫做一个向量的标准化(Normalizing)。单位向量头上有一个^样子的记号。通常单位向量会变得很有用，特别是在我们只关心方向不关心长度的时候（如果改变向量的长度，它的方向并不会改变）。

#### 向量乘法

##### 点乘

两个向量的点乘等于它们的数乘结果乘以两个向量之间夹角的余弦值。计算公式是：

![点乘公式](https://github.com/CodeWicky/Learning-OpenGL/raw/master/%E5%85%A5%E9%97%A8/Pics/%E7%82%B9%E4%B9%98%E5%85%AC%E5%BC%8F.png)

实际计算的方式是对应为相乘：

![点乘计算方式](https://github.com/CodeWicky/Learning-OpenGL/raw/master/%E5%85%A5%E9%97%A8/Pics/%E7%82%B9%E4%B9%98%E8%AE%A1%E7%AE%97%E6%96%B9%E5%BC%8F.png)

根据这个公式我们能反推出求两向量夹角的公式：

![夹角公式](https://github.com/CodeWicky/Learning-OpenGL/raw/master/%E5%85%A5%E9%97%A8/Pics/%E6%B1%82%E5%A4%B9%E8%A7%92%E5%85%AC%E5%BC%8F.png)

##### 叉乘

> 叉乘只在3D空间中有定义，它需要两个不平行向量作为输入，生成一个正交于两个输入向量的第三个向量。如果输入的两个向量也是正交的，那么叉乘之后将会产生3个互相正交的向量。

计算公式：

![叉乘公式](https://github.com/CodeWicky/Learning-OpenGL/raw/master/%E5%85%A5%E9%97%A8/Pics/%E5%8F%89%E4%B9%98%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F.png)


### 矩阵

简单来说矩阵就是一个矩形的数字、符号或表达式数组。矩阵中每一项叫做矩阵的元素(Element)。下面是一个2×3矩阵的例子：

![矩阵](https://github.com/CodeWicky/Learning-OpenGL/raw/master/%E5%85%A5%E9%97%A8/Pics/%E7%9F%A9%E9%98%B5.png)

#### 矩阵的加减

![矩阵加减法](https://github.com/CodeWicky/Learning-OpenGL/raw/master/%E5%85%A5%E9%97%A8/Pics/%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8A%A0%E5%87%8F%E6%B3%95.png)

#### 矩阵的数乘

![矩阵数乘](https://github.com/CodeWicky/Learning-OpenGL/raw/master/%E5%85%A5%E9%97%A8/Pics/%E7%9F%A9%E9%98%B5%E7%9A%84%E6%95%B0%E4%B9%98.png)

#### 矩阵相乘

矩阵乘法基本上意味着遵照规定好的法则进行相乘。当然，相乘还有一些限制：

- 1.只有当左侧矩阵的列数与右侧矩阵的行数相等，两个矩阵才能相乘。
- 2.矩阵相乘不遵守交换律(Commutative)。

![矩阵相乘](https://github.com/CodeWicky/Learning-OpenGL/raw/master/%E5%85%A5%E9%97%A8/Pics/%E7%9F%A9%E9%98%B5%E7%9B%B8%E4%B9%98.png)

### 矩阵与向量相乘

扔了这么一大堆公式，让人想起令人头痛的高中数学。为了什么呢？就是为了仿射变换啊。之前，我们用vec4表示GL中的一个坐标，vec4表示一个RGBA的色值。当我们相对点进行变幻时，我们可以通过改变向量的值来表示变换。我们希望抽出一个数学模型，可以满足缩放、旋转、平移这些过程，我们要借助什么呢？

此处我们恰好可以通过矩阵与向量的相乘来完成这个变换，在此之前，我们先要引入一个概念，单位矩阵。

#### 单位矩阵

如图，下面的矩阵就是一个单位矩阵：

![单位矩阵](https://github.com/CodeWicky/Learning-OpenGL/raw/master/%E5%85%A5%E9%97%A8/Pics/%E5%8D%95%E4%BD%8D%E7%9F%A9%E9%98%B5.png)

那么单位矩阵的好处是什么呢？

> 他与向量相乘，可以不对向量造成任何变换。所以单位矩阵通常是生成其他变换矩阵的起点。

![单位矩阵乘向量](https://github.com/CodeWicky/Learning-OpenGL/raw/master/%E5%85%A5%E9%97%A8/Pics/%E5%8D%95%E4%BD%8D%E7%9F%A9%E9%98%B5%E4%B9%98%E5%90%91%E9%87%8F.png)

#### 缩放

![缩放变换](https://github.com/CodeWicky/Learning-OpenGL/raw/master/%E5%85%A5%E9%97%A8/Pics/%E7%BC%A9%E6%94%BE%E5%8F%98%E6%8D%A2.png)

#### 旋转



#### 位移



### 矩阵的组合

有了上述的介绍，我们对仿射变换有了一个大致的了解，比较重要的一点是，我们可以对几种变换进行组合，求出一个可以代表所有变换的矩阵，然后让视图按照这个矩阵进行变换即可。

假设我们有一个顶点(x, y, z)，我们希望将其缩放2倍，然后位移(1, 2, 3)个单位。我们需要一个位移和缩放矩阵来完成这些变换。结果的变换矩阵看起来像这样：

这里我们需要注意的是，之前我们有说过，矩阵乘法是不支持交换律的。所以这个顺序我们是已固定顺序的。如上述的顺序乘出的结果我们可以看到是我们所预期的。然而如果掉一个书序的话，我们会发现位移也被放大了。所以在仿射变换的时候我们应该注意如下规则：

> 先做缩放，再做旋转，最后做平移。那么相对应的矩阵组合中就是，先做的变换写在乘法的最后面。

矩阵组合之后，直接乘上向量即可对向量完成仿射变换。











